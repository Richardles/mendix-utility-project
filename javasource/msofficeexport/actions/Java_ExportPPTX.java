// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package msofficeexport.actions;

import java.util.ArrayList;
import java.util.List;
import java.awt.Color;
import java.awt.geom.Rectangle2D;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.IOException;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.sl.usermodel.PaintStyle;
import org.apache.poi.sl.usermodel.TextParagraph;
import org.apache.poi.xslf.usermodel.XMLSlideShow;
import org.apache.poi.xslf.usermodel.XSLFSlide;
import org.apache.poi.xslf.usermodel.XSLFSlideLayout;
import org.apache.poi.xslf.usermodel.XSLFShape;
import org.apache.poi.xslf.usermodel.XSLFTextShape;
import org.apache.poi.xslf.usermodel.XSLFTextParagraph;
import org.apache.poi.xslf.usermodel.XSLFTextRun;
import org.apache.poi.xslf.usermodel.XSLFGroupShape;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.MendixRuntimeException;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.UserAction;

/**
 * --- POWERPOINT EXPORT ---
 * 
 * USAGE
 * • This module allows export from Mendix to PowerPoint (.pptx).
 * • Find it as a Java action "Export to PowerPoint" in the Toolbox and place it in your microflow.
 * • When you double-click the action in your microflow, you will see the needed inputs and also some examples. Only one input is described as REQUIRED there. If you do not fill in this input, you will get NullPointerException from the Java action. All other inputs are optional.
 * • This module demonstrates the usage, see the Domain Model and the demonstration microflow (ACT_ExportPPTX).
 * 
 * POWERPOINT TEMPLATE
 * • A normal PowerPoint file is used as a "Template".
 * • This file has to consist of at least 3 slides:
 *    • 1st slide is used for introduction
 *    • 3rd slide is used for conclusion
 *    • 2nd slide will be duplicated and used for all other pages
 *    • any other pages are ignored and will stay in the exported pptx
 * 
 * • The used Java package has some limitations. When duplicating the 2nd slide, SVG images will create problems. In PowerPoint, right-click on every imported vector image (like from SVG file) on the 2nd page and select 'Convert to Shape'.
 * 
 * • You can basically create two types of PowerPoint template file:
 *    a) Slides without any text shapes (boxes with text). In this case, text shapes and text will be placed to default placement decided by this module. You can place e.g. backgrounds to your slides, this will be retained in the export.
 * 
 *    b) On every slide, there are 2 text shapes with some dummy text. In this case, all the basic formatting and placement of the text shapes will be retained and the text will be replaced. The first text shape will be used for title, the second for text. Text color is a formatting that will NOT and can not be retained (due to limitations of the used Java package). 
 * 
 * POWERPOINT CONTENTS
 * • Place titles, paragraphs and bullet points inside a structured JSON file, this JSON will be parsed and processed by the module
 * • Follow the structure:
 *    •  A page can only have "points" or a "paragraph", not both (otherwise an error is thrown)
 *    • There has to be a title and a paragraph/points in a page. Missing title or missing paragraph/points will throw an error
 * 
 * • An example of the JSON document content
 * 
 * {
 *   "document_name": "My Single Document",
 *   "first_page": {
 *     "title": "Introduction",
 *     "points": [
 *       {
 *         "content": "Welcome to the document."
 *       },
 *       {
 *         "content": "This document covers several topics."
 *       }
 *     ]
 *   },
 *   "pages": [
 *     {
 *       "title": "Chapter 1",
 *       "points": [
 *         {
 *           "content": "This is the first point of Chapter 1."
 *         },
 *         {
 *           "content": "This is the second point of Chapter 1."
 *         },
 *         {
 *           "content": "This is the third point of Chapter 1."
 *         }
 *       ]
 *     },
 *     {
 *       "title": "Chapter 2",
 *       "paragraph": "This chapter covers detailed explanations and discussions on the topic. It is meant to provide in-depth analysis and understanding."
 *     }
 *   ],
 *   "final_page": {
 *     "title": "Conclusion",
 *     "points": [
 *       {
 *         "content": "Summary of the document."
 *       },
 *       {
 *         "content": "Final thoughts and recommendations."
 *       }
 *     ]
 *   }
 * }
 * 
 * IMAGE CREDITS
 * 
 * • Icon credits: performance icons created by SeyfDesigner - Flaticon.
 */
public class Java_ExportPPTX extends UserAction<IMendixObject>
{
	private final java.lang.String documentContentJson;
	/** @deprecated use templatePptx.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __templatePptx;
	private final system.proxies.FileDocument templatePptx;
	private final java.lang.String textColor;
	private final java.lang.String textFont;
	private final java.lang.String accentColor;

	public Java_ExportPPTX(
		IContext context,
		java.lang.String _documentContentJson,
		IMendixObject _templatePptx,
		java.lang.String _textColor,
		java.lang.String _textFont,
		java.lang.String _accentColor
	)
	{
		super(context);
		this.documentContentJson = _documentContentJson;
		this.__templatePptx = _templatePptx;
		this.templatePptx = _templatePptx == null ? null : system.proxies.FileDocument.initialize(getContext(), _templatePptx);
		this.textColor = _textColor;
		this.textFont = _textFont;
		this.accentColor = _accentColor;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = this.getContext();
		ILogNode logger = Core.getLogger("Java_ExportPPTX");

		ObjectMapper objectMapper = new ObjectMapper();

		// Default input parameter values, trim spaces
		String inputTextColor = (this.textColor != null) ? this.textColor.trim() : "#000000";
		String inputTextFont = (this.textFont != null) ? this.textFont.trim() : null;
		String inputAccentColor = (this.accentColor != null) ? this.accentColor.trim() : "#7B7B7B";

		// Regular expression for a valid hex color in the format #000000
		String hexColorPattern = "^#([A-Fa-f0-9]{6})$";

		// Validate the textColor
		if (inputTextColor != null && !inputTextColor.matches(hexColorPattern)) {
			logger.error("Invalid textColor format: " + inputTextColor + ". Expected format is #000000.");
		    throw new MendixRuntimeException("Invalid textColor format: " + inputTextColor + ". Expected format is #000000.");
		}

		// Validate the accentColor
		if (inputAccentColor != null && !inputAccentColor.matches(hexColorPattern)) {
			logger.error("Invalid accentColor format: " + inputAccentColor + ". Expected format is #000000.");
		    throw new MendixRuntimeException("Invalid accentColor format: " + inputAccentColor + ". Expected format is #000000.");
		}

		// Validation of textFont not needed. If wrong, the default font will be used (Calibri).

		// Replace all double single apostrophes with a single apostrophe
		String inputDocumentContentJson = documentContentJson.replace("''", "'");

		XMLSlideShow ppt = null;
		ByteArrayOutputStream baos = null;

		try {

			// Parse the document in JSON
			Document document = objectMapper.readValue(inputDocumentContentJson, Document.class);

			// Is the PPTX template provided?
			if (this.templatePptx == null) {
	            ppt = new XMLSlideShow();
	            for (int i = 0; i < 3; i++) {
	                ppt.createSlide();
	            }
	        } else {
	            InputStream templateInputStream = Core.getFileDocumentContent(context, templatePptx.getMendixObject());
	            ppt = new XMLSlideShow(templateInputStream);
	        }

        	// Process the first page
        	processSlide(ppt.getSlides().get(0), document.getFirstPage(), inputTextColor, inputTextFont, inputAccentColor);

            // Process the final page
            processSlide(ppt.getSlides().get(2), document.getFinalPage(), inputTextColor, inputTextFont, inputAccentColor);

            // Process pages 2 through n
            XSLFSlide secondSlideTemplate = ppt.getSlides().get(1);
            int slideIndex = 2;
            for (Page page : document.getPages()) {
                // Duplicate the second slide
                XSLFSlideLayout layout = secondSlideTemplate.getSlideLayout();
                XSLFSlide newSlide = ppt.createSlide(layout);
                /*
                 *  Apache POI limitation: .importContent() does not import vector (SVG) images correctly.
                 *  In PowerPoint, right-click on the image and select 'Convert to Shape'.
                 */
                newSlide.importContent(secondSlideTemplate);

                // Process the slide with the current page content
                processSlide(newSlide, page, inputTextColor, inputTextFont, inputAccentColor);

                // Move the new slide to the correct position
                ppt.setSlideOrder(newSlide, slideIndex);
                slideIndex++;
            }

            // Remove the original second slide template after processing all pages
            ppt.removeSlide(1);

            // Save the presentation to a byte array
        	baos = new ByteArrayOutputStream();
            ppt.write(baos);

            // Convert byte array to InputStream
            InputStream is = new ByteArrayInputStream(baos.toByteArray());

            // Create Mendix FileDocument
            IMendixObject fileDocument = Core.instantiate(context, "MSOfficeExport.ExportedDocument");
			// This commits the object
            Core.storeFileDocumentContent(context, fileDocument, document.getDocumentName() + ".pptx", is);

            return fileDocument;

        } catch (IOException e) {
        	// This also validates the JSON and PPTX file
        	logger.error("Error while generating PowerPoint presentation: " + e.getClass().getName() + ": " + e.getMessage(), e);
        	throw new MendixRuntimeException("Error while generating PowerPoint presentation.", e);
        } finally {
        	ppt.close();
        	baos.close();
        }

		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "Java_ExportPPTX";
	}

	// BEGIN EXTRA CODE

	/**
	 * This class is used to map the JSON structure of a document.
	 */
	private static class Document {

	    @JsonProperty("document_name")
	    private String documentName;

	    @JsonProperty("first_page")
	    private Page firstPage;

	    private List<Page> pages;

	    @JsonProperty("final_page")
	    private Page finalPage;

	    public String getDocumentName() {
	        return documentName;
	    }

	    public Page getFirstPage() {
	        return firstPage;
	    }

	    public List<Page> getPages() {
	        return pages;
	    }

	    public Page getFinalPage() {
	        return finalPage;
	    }

	}

	private static class Page {

	    private String title;
	    private List<Point> points;
	    private String paragraph;

	    public String getTitle() {
	        return title;
	    }

	    public List<Point> getPoints() {
	        return points;
	    }

	    public String getParagraph() {
	        return paragraph;
	    }

	}

	private static class Point {

	    private String content;

	    public String getContent() {
	        return content;
	    }

	}

	/**
	 * <p>Replaces the text in the given {@link XSLFTextShape} while preserving the existing formatting. Enlarges the text shape if it is too small.</p>
	 *
	 * <strong>Apache POI limitations:</strong>
	 * <ul>
	 *   <li>Does not preserve a custom color – the color will be replaced with the nearest theme color.</li>
	 *   <li>Does not preserve custom formatting if the text shape is empty.</li>
	 * </ul>
	 *
	 * @param textShape the {@link XSLFTextShape} in which the text will be replaced
	 * @param content the new content to set in the {@link XSLFTextShape}, either a {@link String} or a {@link List<Point>}
	 * @param customTextColor text color in hex format (e.g., "#0000ff"), overrides the original captured color. If empty "" or null, the original color is preserved.
	 * @param minWidth the minimum width allowed for the text box before resizing
     * @param minHeight the minimum height allowed for the text box before resizing
     * @param defaultWidth the default width to set if the current width is below the minimum
     * @param defaultHeight the default height to set if the current height is below the minimum
     *
     * @throws MendixRuntimeException if the content is neither a {@link String} nor a {@link List} of {@link Point}.
	 */
	private static <T> void replaceTextPreservingStyle(XSLFTextShape textShape, T content, String customTextColor, int minWidth, int minHeight, int defaultWidth, int defaultHeight) {
	    // Check and adjust dimensions if necessary
	    Rectangle2D anchor2D = textShape.getAnchor();
	    java.awt.Rectangle anchor = new java.awt.Rectangle(
	        (int) anchor2D.getX(),
	        (int) anchor2D.getY(),
	        (int) anchor2D.getWidth(),
	        (int) anchor2D.getHeight()
	    );

	    int width = anchor.width;
	    int height = anchor.height;

	    if (width < minWidth || height < minHeight) {
	        int newWidth = Math.max(defaultWidth, width);
	        int newHeight = Math.max(defaultHeight, height);
	        textShape.setAnchor(new java.awt.Rectangle(anchor.x, anchor.y, newWidth, newHeight));
	    }

	    // Get text runs and text paragraph
	    List<XSLFTextRun> textRuns = textShape.getTextParagraphs().get(0).getTextRuns();
	    XSLFTextParagraph textParagraph = textShape.getTextParagraphs().get(0);

	    // Set defaults if the text shape is empty
	    Color fontColor = null;
	    Double fontSize = null;
	    String fontFamily = null;
	    boolean isBold = false;
	    boolean isItalic = false;
	    boolean isUnderlined = false;
	    TextParagraph.TextAlign textAlign = TextParagraph.TextAlign.LEFT;
		Double indent = 0.0;

	    // Capture the formatting of the first text run
	    if (!textRuns.isEmpty()) {
	        XSLFTextRun firstTextRun = textRuns.get(0);
	        PaintStyle fontPaint = firstTextRun.getFontColor();
	        if (fontPaint instanceof PaintStyle.SolidPaint) {
	            PaintStyle.SolidPaint solidPaint = (PaintStyle.SolidPaint) fontPaint;
	            int rgbColor = solidPaint.getSolidColor().getColor().getRGB();
	            fontColor = new Color(rgbColor);
	        }
	        fontSize = firstTextRun.getFontSize();
	        fontFamily = firstTextRun.getFontFamily();
	        isBold = firstTextRun.isBold();
	        isItalic = firstTextRun.isItalic();
	        isUnderlined = firstTextRun.isUnderlined();
	        textAlign = textParagraph.getTextAlign();
			indent = textParagraph.getIndent();
	    }

	    // Clear existing text
	    textShape.clearText();

	    // Determine the text color to use
	    if (customTextColor != null && !customTextColor.isEmpty()) {
	        fontColor = Color.decode(customTextColor);
	    }

        // Handle the case where content is a paragraph
	    if (content instanceof String) {

	        XSLFTextRun newTextRun = textShape.addNewTextParagraph().addNewTextRun();
	        newTextRun.setText((String) content);

	        // Apply the captured formatting to the new text run
	        if (fontColor != null) {
	            newTextRun.setFontColor(fontColor);
	        }
	        if (fontSize != null) {
	            newTextRun.setFontSize(fontSize);
	        }
	        if (fontFamily != null) {
	            newTextRun.setFontFamily(fontFamily);
	        }
	        newTextRun.setBold(isBold);
	        newTextRun.setItalic(isItalic);
	        newTextRun.setUnderlined(isUnderlined);

	        // Apply the captured alignment and indent to the new text paragraph
	        textShape.getTextParagraphs().get(0).setTextAlign(textAlign);
			textShape.getTextParagraphs().get(0).setIndent(indent);

	    // Handle the case where content is a list of points
	    } else if (content instanceof List) {

			List<Point> points = (List<Point>) content;

	        for (Point point : points) {
	            XSLFTextParagraph paragraph = textShape.addNewTextParagraph();
	            paragraph.setBullet(true); // Set bullet points
	            XSLFTextRun textRun = paragraph.addNewTextRun();
	            textRun.setText(point.getContent());

	            // Apply the captured formatting to each new text run
	            if (fontColor != null) {
	                textRun.setFontColor(fontColor);
	            }
	            if (fontSize != null) {
	                textRun.setFontSize(fontSize);
	            }
	            if (fontFamily != null) {
	                textRun.setFontFamily(fontFamily);
	            }
	            textRun.setBold(isBold);
	            textRun.setItalic(isItalic);
	            textRun.setUnderlined(isUnderlined);

	            // Apply the captured alignment and indent to the new text paragraph
	            paragraph.setTextAlign(textAlign);
				paragraph.setIndent(indent);
	        }

	    } else {
	    	Core.getLogger("Java_ExportPPTX").error("Error when replacing text on a slide. Content must be either a String (paragraph) or a List of points.");
	        throw new MendixRuntimeException("Error when replacing text on a slide. Content must be either a String (paragraph) or a List of points.");
	    }
	}

	/**
	 * Recursively find text shapes within a group shape.
	 *
	 * @param groupShape The group shape to search within.
	 * @return A list of text shapes found within the group.
	 */
	private static List<XSLFTextShape> findTextShapesInGroup(XSLFGroupShape groupShape) {
	    List<XSLFTextShape> textShapes = new ArrayList<>();
	    for (XSLFShape shape : groupShape.getShapes()) {
	        if (shape instanceof XSLFTextShape) {
	            textShapes.add((XSLFTextShape) shape);
	        } else if (shape instanceof XSLFGroupShape) {
	            textShapes.addAll(findTextShapesInGroup((XSLFGroupShape) shape));
	        }
	    }
	    return textShapes;
	}

	/**
	 * Creates a text shape on a given slide with specified properties.
	 *
	 * Note: Top-left corner = 0,0. Default slide dimensions = 720 x 540.
	 *
	 * @param <T>       The type of the content, which can be either a {@link String} or a {@link List} of {@link Point}.
	 * @param slide     The {@link XSLFSlide} on which the text shape will be created.
	 * @param x         The x-coordinate of the top-left corner of the text shape.
	 * @param y         The y-coordinate of the top-left corner of the text shape.
	 * @param width     The width of the text shape.
	 * @param height    The height of the text shape.
	 * @param content   The content to be displayed in the text shape. Can be a {@link String} or a {@link List} of {@link Point}.
	 * @param textColor The color of the text, specified as a hexadecimal string (e.g., "#FF0000" for red).
	 * @param font      The font family of the text.
	 * @param bold      Whether the text should be bold.
	 * @param fontSize  The size of the font.
	 *
	 * @throws MendixRuntimeException if the content is neither a {@link String} nor a {@link List} of {@link Point}.
	 */
	private static <T> void createTextShape(XSLFSlide slide, int x, int y, int width, int height, T content, String textColor, String font, boolean bold, double fontSize) {
	    XSLFTextShape textShape = slide.createTextBox();
	    textShape.setAnchor(new java.awt.Rectangle(x, y, width, height));

	    Color fontColor = null;
	    if (textColor != null && !textColor.isEmpty()) {
	        fontColor = Color.decode(textColor);
	    }

	    if (content instanceof String) {
	        XSLFTextParagraph paragraph = textShape.addNewTextParagraph();
	        XSLFTextRun textRun = paragraph.addNewTextRun();
	        textRun.setText((String) content);
	        if (fontColor != null) {
	            textRun.setFontColor(fontColor);
	        }
	        textRun.setFontFamily(font);
	        textRun.setBold(bold);
	        textRun.setFontSize(fontSize);

	    } else if (content instanceof List) {

	        List<Point> points = (List<Point>) content;

	        for (Point point : points) {
	            XSLFTextParagraph paragraph = textShape.addNewTextParagraph();
	            paragraph.setBullet(true);
	            paragraph.setIndent(20.0);
	            XSLFTextRun textRun = paragraph.addNewTextRun();
	            textRun.setText(point.getContent());
	            if (fontColor != null) {
	                textRun.setFontColor(fontColor);
	            }
	            textRun.setFontFamily(font);
	            textRun.setBold(bold);
	            textRun.setFontSize(fontSize);
	        }

	    } else if (content == null) {
		    Core.getLogger("Java_ExportPPTX").error("Error when placing text on a slide. A title or paragraph/points are missing from the JSON.");
		    throw new MendixRuntimeException("Error when placing text on a slide. A title or paragraph/points are missing from the JSON.");

	    } else {
	    	Core.getLogger("Java_ExportPPTX").error("Error when placing text on a slide. Content must be either a String (paragraph) or a List of points.");
	        throw new MendixRuntimeException("Error when placing text on a slide. Content must be either a String (paragraph) or a List of points.");
	    }
	}

	/**
	 * Processes an XSLFSlide by identifying or creating title and body text shapes and applying text content from a Page object.
	 *
	 * <p>This method attempts to detect the first two text shapes (either single or within groups) on the slide.
	 * If these shapes are found, it replaces their text with the title and content from the Page object while preserving the original style.
	 * If no text shapes are found, new ones are created.</p>
	 *
	 * @param slide       The slide to process. This must be an instance of {@link org.apache.poi.xslf.usermodel.XSLFSlide}.
	 * @param page        The page object containing the title and content to be inserted into the slide. This must be an instance of {@link Page}.
	 * @param textColor   The color to apply to the body text (in hex format like "#000000").
	 * @param textFont    The font to apply to the text.
	 * @param accentColor The color to apply to the title text (in hex format like "#FF0000").
	 */
	private static void processSlide(XSLFSlide slide, Page page, String textColor, String textFont, String accentColor) {

		// Detect the first two text shapes on the page (single or grouped) containing a text (not empty)
        XSLFTextShape titleShape = null;
        XSLFTextShape bodyShape = null;

        for (XSLFShape shape : slide.getShapes()) {
            if (shape instanceof XSLFTextShape) {
                XSLFTextShape textShape = (XSLFTextShape) shape;
                if (textShape.getText() != null && !textShape.getText().isEmpty()) {
                    if (titleShape == null) {
                        titleShape = textShape;
                    } else if (bodyShape == null) {
                        bodyShape = textShape;
                    } else {
                        break;
                    }
                }
            } else if (shape instanceof XSLFGroupShape) {
                XSLFGroupShape groupShape = (XSLFGroupShape) shape;
                List<XSLFTextShape> textShapes = findTextShapesInGroup(groupShape);
                for (XSLFTextShape textShape : textShapes) {
                    if (textShape.getText() != null && !textShape.getText().isEmpty()) {
                        if (titleShape == null) {
                            titleShape = textShape;
                        } else if (bodyShape == null) {
                            bodyShape = textShape;
                        } else {
                            break;
                        }
                    }
                }
            }
        }

        // No text shapes found, create both
        if (titleShape == null && bodyShape == null) {
            	createTextShape(slide, 50, 50, 620, 50, page.getTitle(), accentColor, textFont, true, 36.0);
            if (page.getPoints() != null) {
            	createTextShape(slide, 50, 120, 620, 300, page.getPoints(), textColor, textFont, false, 18.0);
            } else if (page.getParagraph() != null) {
            	createTextShape(slide, 50, 120, 620, 300, page.getParagraph(), textColor, textFont, false, 18.0);
            }

        // Only one text shape found, create the second one
        } else if (titleShape != null && bodyShape == null) {
        	replaceTextPreservingStyle(titleShape, page.getTitle(), accentColor, 50, 50, 100, 100);
        	if (page.getPoints() != null) {
            	createTextShape(slide, 50, 120, 620, 300, page.getPoints(), textColor, textFont, false, 18.0);
            } else if (page.getParagraph() != null) {
            	createTextShape(slide, 50, 120, 620, 300, page.getParagraph(), textColor, textFont, false, 18.0);
            }
        }

        // Both text shapes found
        if (titleShape != null && bodyShape != null) {
        		replaceTextPreservingStyle(titleShape, page.getTitle(), accentColor, 50, 50, 100, 100);
        	if (page.getPoints() != null) {
        		replaceTextPreservingStyle(bodyShape, page.getPoints(), textColor, 50, 50, 100, 200);
        	} else if (page.getParagraph() != null) {
                replaceTextPreservingStyle(bodyShape, page.getParagraph(), textColor, 50, 50, 100, 200);
            }
		}

	}

	// END EXTRA CODE
}
