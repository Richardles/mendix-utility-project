// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package msofficeexport.actions;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import java.io.InputStream;
import java.util.List;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.apache.poi.xwpf.usermodel.XWPFTable;
import org.apache.poi.xwpf.usermodel.XWPFTableCell;
import org.apache.poi.xwpf.usermodel.XWPFTableRow;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.MendixRuntimeException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;

/**
 * --- WORD EXPORT (PLACEHOLDERS BASED) ---
 * 
 * USAGE
 * 
 * • This module allows export from Mendix to Word (.docx) based on key-value pairs given as JSON.
 *   • In the Word template, use placeholders like {1}, {2}, {3} and so on
 *   • With JSON, you tell it with what strings to replace the placeholders
 * 
 * • Find it as a Java action "Export to Word (Placeholders)" in the Toolbox and place it in your microflow.
 * • When you double-click the action in your microflow, you will see the needed inputs and also some examples. Some inputs are described as REQUIRED there. If you do not fill in these inputs, you will get NullPointerException from the Java action.
 * • This module demonstrates the usage, see the Domain Model and the demonstration microflow (ACT_ExportPlaceholdersDOCX).
 * 
 * WORD TEMPLATE
 * 
 * • You have to give a Word document that will be used as the template by the module.
 * • In the Word document, use placeholders like like {1}, {2}, {3} and so on (unlimited number)
 * 
 * • The placeholders will work only if placed in paragraphs (titles, headings etc. included) or tables
 *    • Placeholders in other parts of Word document, like footer, header, comments and so on will be not replaced
 *    • Placeholders in nested tables (tables in tables) do not work reliably due to Apache POI (the used Java library) limitations. Do not use nested tables or use only tested templates that work.
 * 
 * WORD CONTENTS
 * 
 * • An example of the JSON document contents:
 * 
 * {
 *   "1": "An interesting sentence.",
 *   "2": "What we do.",
 *   "3": "13. 5. 2024",
 *   "4": "James Smith",
 *   "5": "Green Street 12, Prague 5",
 *   "6": "5/18/2023",
 *   "7": "200.00 €",
 *   "8": "123456789/0200"
 * }
 * 
 * IMAGE CREDITS
 * 
 * • Icon credits: document icons created by Driss Lebbat - Flaticon.
 */
public class Java_ExportPlaceholdersDOCX extends UserAction<IMendixObject>
{
	private final java.lang.String documentContentJson;
	/** @deprecated use templateDocx.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __templateDocx;
	private final msofficeexport.proxies.TemplateDocx templateDocx;
	private final java.lang.String exportedFileName;

	public Java_ExportPlaceholdersDOCX(
		IContext context,
		java.lang.String _documentContentJson,
		IMendixObject _templateDocx,
		java.lang.String _exportedFileName
	)
	{
		super(context);
		this.documentContentJson = _documentContentJson;
		this.__templateDocx = _templateDocx;
		this.templateDocx = _templateDocx == null ? null : msofficeexport.proxies.TemplateDocx.initialize(getContext(), _templateDocx);
		this.exportedFileName = _exportedFileName;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = this.getContext();
		ILogNode logger = Core.getLogger("Java_ExportPlaceholdersDOCX");

		// Load the template document
        InputStream templateInputStream = Core.getFileDocumentContent(context, templateDocx.getMendixObject());
        document = new XWPFDocument(templateInputStream);

		Map<String, String> placeholders = parseJsonToMap(this.documentContentJson);

		try {

			replaceTextInParagraphs(document, placeholders);
            replaceTextInTables(document, placeholders);

			ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            this.document.write(outputStream);

			// Create a Mendix file document
			IMendixObject fileDocument = Core.instantiate(getContext(), "MSOfficeExport.ExportedDocument");
			InputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
			// This commits the object
			Core.storeFileDocumentContent(getContext(), fileDocument, this.exportedFileName + ".docx", inputStream);

			return fileDocument;

		} catch (IOException e) {
        	// This also validates the JSON and DOCX file
        	logger.error("Error while generating Word document: " + e.getClass().getName() + ": " + e.getMessage(), e);
        	throw new MendixRuntimeException("Error while generating Word document.", e);
        } finally {
        	this.document.close();
        }

		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "Java_ExportPlaceholdersDOCX";
	}

	// BEGIN EXTRA CODE
	private XWPFDocument document;

	/**
	 * Parses a JSON string into a Map of key-value pairs.
	 *
	 * @param jsonContent The JSON string representing the key-value pairs.
	 * @return A Map containing the parsed key-value pairs from the JSON string.
	 * @throws IOException If an error occurs during parsing of the JSON string.
	 */
	private Map<String, String> parseJsonToMap(String jsonContent) throws IOException {
		ObjectMapper objectMapper = new ObjectMapper();
		return objectMapper.readValue(jsonContent, new TypeReference<Map<String, String>>(){});
	}


	/**
	 * Replaces placeholders in the paragraphs of a Word document with the corresponding values from the given map.
	 *
	 * @param document The XWPFDocument object representing the Word document.
	 * @param placeholders A Map containing placeholder keys and their corresponding replacement values.
	 */
	private void replaceTextInParagraphs(XWPFDocument document, Map<String, String> placeholders) {
		List<XWPFParagraph> paragraphs = document.getParagraphs();

		for (XWPFParagraph paragraph : paragraphs) {
			List<XWPFRun> runs = paragraph.getRuns();

			for (XWPFRun run : runs) {
				String text = run.getText(0);
				if (text != null) {
					for (Map.Entry<String, String> entry : placeholders.entrySet()) {
						text = text.replace("{" + entry.getKey() + "}", entry.getValue());
					}
					run.setText(text, 0);  // Update the text while preserving formatting
				}
			}
		}
	}

	/**
	 * Replaces placeholders in the tables of a Word document with the corresponding values from the given map.
	 *
	 * @param document The XWPFDocument object representing the Word document.
	 * @param placeholders A Map containing placeholder keys and their corresponding replacement values.
	 */
	private void replaceTextInTables(XWPFDocument document, Map<String, String> placeholders) {
		List<XWPFTable> tables = document.getTables();

		for (XWPFTable table : tables) {
			processTable(table, placeholders);
		}
	}


	/**
	 * Processes a table in a Word document, replacing placeholders in each cell with the corresponding values from the given map.
	 *
	 * @param table The XWPFTable object representing the table to process.
	 * @param placeholders A Map containing placeholder keys and their corresponding replacement values.
	 */
	private void processTable(XWPFTable table, Map<String, String> placeholders) {
		for (XWPFTableRow row : table.getRows()) {
			for (XWPFTableCell cell : row.getTableCells()) {

				for (XWPFParagraph paragraph : cell.getParagraphs()) {
					processParagraph(paragraph, placeholders);
				}

				for (XWPFTable nestedTable : cell.getTables()) {
					processTable(nestedTable, placeholders);
				}
			}
		}
	}

	/**
	 * Processes a paragraph in a Word document, replacing placeholders with the corresponding values from the given map.
	 *
	 * @param paragraph The XWPFParagraph object representing the paragraph to process.
	 * @param placeholders A Map containing placeholder keys and their corresponding replacement values.
	 */
	private void processParagraph(XWPFParagraph paragraph, Map<String, String> placeholders) {
		List<XWPFRun> runs = paragraph.getRuns();

		for (XWPFRun run : runs) {
			String text = run.getText(0);
			if (text != null) {
				for (Map.Entry<String, String> entry : placeholders.entrySet()) {
					text = text.replace("{" + entry.getKey() + "}", entry.getValue());
				}
				run.setText(text, 0);  // Update the text while preserving formatting
			}
		}
	}


	// END EXTRA CODE
}
